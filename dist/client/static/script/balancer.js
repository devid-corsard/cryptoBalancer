/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/balancer/cryptobalancer.js":
/*!***********************************************!*\
  !*** ./src/client/balancer/cryptobalancer.js ***!
  \***********************************************/
/***/ (() => {

eval("const values = {\n  btcPrice: \"BTC Price:\",\n  btcAmount: \"BTC Amount:\",\n  btcInUsd: \"BTC in USD:\",\n  difference: \"Difference:\",\n  usdAmount: \"USD Amount:\",\n  totalInUsd: \"Total in USD:\",\n}\n\nconst msg = {\n  resetAlert: 'RESET ALL DATA IN TABLE?',\n  copyDone: 'DATA COPIED. YOU SHOULD SAVE IT TO TEXT FILE',\n  pasteWarning: 'You really want to paste this?'\n}\n\nconst table = document.getElementById('table')\n\nlet rows = localStorage.rows\n  ? JSON.parse(localStorage.getItem(\"rows\"))\n  : createInitialRows();\n\ntable.addEventListener('input', e => {\n  updateData(e.target)\n})\n\nrenderTable()\n\nfunction renderTable() {\n  table.innerHTML = ''\n  createHead()\n  renderInputsFrom(rows)\n  renderKeysFor(rows)\n  saveToLocalStorage()\n}\n\nfunction createInitialRows() {\n  let rows = []\n  let row = {}\n  for(key in values) {\n    row[key] = 0\n  }\n  rows.push(row)\n  return rows\n}\n\nfunction createHead() {\n  let headRow = document.createElement('tr')\n  for (key in values) {\n    let th = document.createElement('th')\n    th.innerText = values[key]\n    headRow.append(th)\n  }\n  table.append(headRow)\n}\n\nfunction renderInputsFrom(rows) {\n  rows.forEach((valuesObj, index) => {\n\n    const row = document.createElement('tr')\n    row.id = index\n\n    Object.keys(valuesObj).forEach(key => {\n\n      const td = document.createElement('td')\n      const input = document.createElement('input')\n      input.className = key\n      input.value = key === 'btcAmount' ? valuesObj[key] : +valuesObj[key].toFixed(2)\n      input.type = 'number'\n\n      if (key === 'totalInUsd') {\n        input.readOnly = true\n        input.type = 'text'\n        input.style.width = '100px'\n      }\n      \n      td.append(input)\n      row.append(td)\n    })\n\n    table.append(row)\n  });\n}\n\nfunction renderKeysFor(rows) {\n  rows.forEach((valuesObj, index) => {\n\n    const row = document.getElementById(index)\n\n    const duplicateButton = document.createElement('button')\n    duplicateButton.textContent = duplicateButton.className = 'duplicate'\n    duplicateButton.addEventListener('click', e => {\n      duplicateRow(e.target)\n    })\n    \n    const deleteButton = document.createElement('button')\n    deleteButton.textContent = deleteButton.className = 'delete'\n    deleteButton.addEventListener('click', e => {\n      deleteRow(e.target)\n    })\n\n    const balanceButton = document.createElement('button')\n    balanceButton.textContent = balanceButton.className = 'balance'\n    balanceButton.addEventListener('click', e => {\n      updateData(e.target)\n    })\n\n    row.append(duplicateButton, balanceButton, deleteButton)\n\n    \n  })\n}\n\nfunction updateData(target) {\n  const inputsRow = target.closest('tr')\n  const id = +inputsRow.id\n  const row = rows[id]\n  const key = target.className\n  \n  if (target.tagName === 'INPUT') {\n    if (+target.value === '') return\n    row[key] = +target.value\n  }\n\n  const inputs = getInputs()\n\n  function getInputs() {\n\n    const inputs = {}\n    for (let key in values) {\n      inputs[key] = inputsRow.querySelector(`.${key}`)\n    }\n    return inputs\n  }\n\n  if (key === 'btcPrice') {\n    getBtcInUsd()\n    getTotal()\n  }\n  if (key === 'btcInUsd') {\n    getBTCAmount()\n    getTotal()\n  }\n  if (key === 'usdAmount') {\n    getTotal()\n  }\n  if (key === 'btcAmount') {\n    getBtcInUsd()\n    getTotal()\n  }\n  if (key === 'balance') {\n    balance()\n    getBTCAmount()\n  }\n  if (key === 'difference') {\n    getUsdAndBtcInUsd()\n    getBTCAmount()\n  }\n  getDifference()\n  saveToLocalStorage()\n\n  function getUsdAndBtcInUsd() {\n    row.usdAmount = (+row.totalInUsd - +row.difference) / 2\n    inputs.usdAmount.value = +row.usdAmount.toFixed(2)\n\n    row.btcInUsd = +row.usdAmount + +row.difference\n    inputs.btcInUsd.value = +row.btcInUsd.toFixed(2)\n\n  }\n\n  function getDifference() {\n    inputs.difference.value = +(row.difference = +row.btcInUsd - +row.usdAmount).toFixed(2)\n    inputs.difference.style.color = inputs.difference.value >= 0 ? 'green' : 'red'\n  }\n  function getBTCAmount() {\n    inputs.btcAmount.value = row.btcAmount = +(+row.btcInUsd / +row.btcPrice).toFixed(8)\n  }\n\n  function getBtcInUsd() {\n    inputs.btcInUsd.value = +(row.btcInUsd = +row.btcAmount * +row.btcPrice).toFixed(2)\n  }\n\n  function getTotal() {\n    inputs.totalInUsd.value = +(row.totalInUsd = +row.btcInUsd + +row.usdAmount).toFixed(2)\n  }\n\n  function balance() {\n    inputs.btcInUsd.value = inputs.usdAmount.value = +(row.btcInUsd = row.usdAmount = +row.totalInUsd / 2).toFixed(2)\n  }\n\n}\n\nfunction duplicateRow(target) {\n\n  const id = +target.closest('tr').id\n  let newRows = []\n  const last = rows.length - 1 - id === 0\n  const clone = Object.assign({}, rows[id])\n  if (id === 0 && !last) {\n    newRows.push(rows[id])\n    newRows.push(clone)\n    newRows.push(...rows.slice(1))\n  } else if (last) {\n    newRows.push(...rows)\n    newRows.push(clone)\n  } else {\n    newRows.push(...rows.slice(0, id))\n    newRows.push(clone)\n    newRows.push(...rows.slice(id))\n  }\n\n  rows = newRows\n\n  renderTable()\n}\n\nfunction deleteRow(target) {\n\n  if (rows.length < 2) {\n    rows = createInitialRows()\n    renderTable()\n    return\n  }\n\n  const id = +target.closest('tr').id\n  \n  rows.splice(id, 1)\n\n  renderTable()\n}\n\nfunction saveToLocalStorage() {\n  localStorage.setItem('rows', JSON.stringify(rows) )\n}\n\nfunction saveToClipBoard() {\n  navigator.clipboard.writeText(JSON.stringify(rows));\n  alert(msg.copyDone)\n}\n\nfunction pasteFromClipBoard() {\n  navigator.clipboard.readText().then(\n    clipText => {\n      if(confirm(msg.pasteWarning + clipText)) {\n        rows = JSON.parse(clipText)\n        renderTable()\n      }\n    }\n  )\n  \n}\n\nfunction resetTable() {\n  if (confirm(msg.resetAlert)) {\n    rows = createInitialRows()\n    renderTable()\n  }\n}\n\n//# sourceURL=webpack://crypto-toolkit/./src/client/balancer/cryptobalancer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client/balancer/cryptobalancer.js"]();
/******/ 	
/******/ })()
;